# -*- coding: utf-8 -*-
"""TAREA4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QBrG5EBw7cvkJiRKypdE1m_gefl1qLpg

La información de las distribuciones se obtuvo de: https://es.wikipedia.org/wiki/Distribuci%C3%B3n_uniforme_continua

las aplicaciones de una clase y una subclase de variables uniformes estándar y continuas son muchas, principalmente para cursos de inferencia y probabilidad. 
Las dos clases incluyen métodos que calculas algunas de las medidas de tendencia central para las variables y otra información util, como la asimetria, curtosis, entre otras. 

Al final del cuaderno se incluyen las pruebas de todos los métodos de cada clase calculados con base en un objeto de la clase creado previamente
"""

class rv_uniforme:


  '''
  Clase propia para la Distribución Uniforme continua ESTÁNDAR
  '''

  ##INICIALIZADOR DE LA CLASE UNIFORME CONTINUA
  def __init__(self, a=0.0, b=1.0 ):
        "Constructor"
        self._a=a
        self._b=b

  ## MÉTODO QUE CONFIGURA EL STRING DE UN OBJETO DE LA DISTRIBUCIÓN
  ### Al imprimir un objeto de esta clase lo imprime con texto antes y después que dan información útil de la distribución.

  def __str__(self):
      "print: X \sim U(a, b)"
      return "~ U("+ str(self.a) +" , "+ str(self.b) +") --objeto de la clase `rv_uniforme`--"
  ##OBTIENE EL PRIMER PARÁMEETRO DE LA DISTRIBUCIÓN
  @property
  def a(self):
      "Para otener el valor a"
      return self._a
  
  ## AJUSTA EL VALOR DEL PRIMER PARÁMETRO DE LA DISTRIBUCIÓN MANTENIÉNDOLO "PRIVADO"
  @a.setter
  def a(self, a1):
      "Para modificar el valor a"
      self._a = a1
      
 
  ## OBTIENE EL SEGUNDO PARÁMETRO DE LA DISSTRIBUCIÓN
  @property
  def b(self):
      "Para otener el valor b"
      return self._b

  ## AJUSTA EL VALOR DEL SEGUNDO PARÁMETRO DE LA DISTRIBUCIÓN MANTENIÉNDOLO "PRIVADO"
  @b.setter
  def b(self, b1):
      "Para modificar el valor b"
      self._b = b1
     
  
  ## MÉTODO QUE DEVUELVE LA  DENSIDAD EN UN X DADO EN EL DOMINIO DE LA DISTRIBUCIÓN

  def PDF(self, x):
        "Función de densidad"
        if ( x>=self.a and self.b>=x) :
          m= (1/(self.b - self.a))
          return  m 
        elif ((x<self.a or self.b<x)) :
          m= (1/(self.b - self.a))
          return  m   
        else:
          print ("x inválido")     
    

       
  ## MÉTODO QUE DEVUELVE LA DENSIDAD ACUMULADA HASTA UN X DADO EN EL DOMINIO DE LA DISTRIBUCIÓN

  def CDF(self, x):
        "Función de distribución acumulativa"
        if x<self.a:
          return 0
        elif  x>self.b:
          return 0
        elif  x>=self.a and self.b >=x:
          return (x-self.a)/( self.b - self.a )
        else:
          print("x inválido")
  ## MÉTODO QUE DEVUELVE EL VALOR DE UN CUANTIL DADO COMO PARÁMETRO
  ## EL CUANTIL ES UN NÚMERO REAL ENTRE O Y 1

  def QF(self, p):
        "Función cuantil"
        if (0<p and p<=1):
          return p*((self.b-self.a))+ self.a
        else:
          print("Cuantil inválido")

  ## MÉTODO QUE DEVUELVE LA PROBABILIDAD DE QUE UN X ESTÉ ENTRE A Y B 

  def Prob(self, aj, bj):
        "Probabilidad entre los valores a y b"
        if  bj > aj:
          return self.CDF(bj) - self.CDF(aj)
        else:
          print("Límites inválidos")

  ## MÉTODO QUE DEVUELVE LA MEDIA DE LA DISTRIBUCIÓN 

  def mean(self):
        "Media"
        return 1/2*(self.a+self.b)
  
  ## MÉTODO QUE DEVUELVE LA VARIANZA DE LA DISTRIBUCIÓN

  def var(self):
      "Varianza"
      return 1/12*((self.b-self.a)**2)
     
  ## MÉTODO QUE DEVUELVE LA DESVIACIÓN ESTÁNDAR DE LA DISTRIBUCIÓN

  def sd(self):
      "Desviación estándar"
      return (1/12*((self.b-self.a)**2))**0.5

  ## MÉTODO QUE DEVUELVE LA ASIMETRÍA DE LA DISTRIBUCIÓN

  def skew(self):
      "Asimetría Skewness"
      return 0

  ## MÉTODO QUE DEVUELVE LA CURTOSIS DE LA DISTRIBUCIÓN

  def EKurt(self):
      "Exceso de curtosis"
      return -6/5

  ## MÉTODO QUE DEVUELVE LA MEDIANA DE LA DISTRIBUCIÓN
    
  def Median(self):
      "Mediana"
      return 1/2*(self.a + self.b)

  ## MÉTODO QUE DEVUELVE EL RANGO INTERCUARÍLICO DE LA DISTRIBUCIÓN

  def IQR(self):
      "Rango intercuartílico"
      return self.QF(0.75)- self.QF(0.25)

  ## MÉTODO QUE DEVUELVE LA MODA DE LA DISTRIBUCIÓN

  def mode(self):
      "Moda"
      
      return 0.5
      ## EL VALOR DE LA MODA ES CUALQUIER VALOR ENTRE A Y B, DEJARÉ FIJO 0.5 MIENTRAS HAGO EL MÉTODO QUE GENERE UN VALOR ALEATORIO ENTRE A Y B

class rv_uniformecont( rv_uniforme):
    '''
    Clase propia para la  Distribución uniforme de parámetros a (menor valor que toma la variable)
    y b (máximo valor que toma la variable)
    '''
    '''
    Clase propia para la Distribución Uniforme continua
    '''

    ## inicializador de la clase
    def __init__(self, a, b):
        "Constructor"
        if isinstance(a, (int,float)):
            self._a = a
        else:
            print("Limites inválidos")
        if (isinstance(b, (int, float)) and b >=a):
            self._b =  b
        else:
            print("Limites inválidos")
        super().__init__(a , b) #Constructor de la clase padre es llamado
        


     ## Recupera el primer parámetro de la distribución.    
    @property
    def a(self):
        return super().a

    ## MÉTODO QUE AJUSTA EL PRIMER PARÁMETRO DE LA DISTRIBUCIÓN MANTENIÉNDOLO "PRIVADO"

    @a.setter
    def a(self, a1):
        "Para modificar el valor a"
        if isinstance(a1, (int, float)):
            self._a = a1
        else:
            raise print("Limites inválidos")
        
    ## RECUPERA EL SEGUNDO PARÁMETRO DE LA DISTRIBUCIÓN 

    @property
    def b(self):
        "Para otener el valor b"
        return super().b
       
   ## MÉTODO QUE AJUSTA EL SEGUNDO PARÁMETRO DE LA DISTRIBUCIÓN MANTENIÉNDOLO "PRIVADO"

    @b.setter
    def b(self, b1):
        "Para modificar el valor b"
        if isinstance(b1, (int,float)) and b1> self.a:
            self._b = b1
        else:
            raise print("Limites inválidos") 
        
        
    ## MÉTODO QUE CONFIGURA EL STRING DE UN OBJETO DE LA DISTRIBUCIÓN
    ### Al imprimir un objeto de esta clase lo imprime con texto antes y después que dan información útil de la distribución.
        
    def __str__(self):
       return super().__str__()+ "\b\b\bcont`--"
    
    ## MÉTODO QUE DEVUELVE LA  DENSIDAD EN UN X DADO EN EL DOMINIO DE LA DISTRIBUCIÓN

    def PDF( self, x):
        "Función de densidad"
        
        m= super().PDF(x)
        return m
    
      ## MÉTODO QUE DEVUELVE LA DENSIDAD ACUMULADA HASTA UN X DADO EN EL DOMINIO DE LA DISTRIBUCIÓN
    
    def CDF(self, x):
        return super().CDF(x)
    
    ## MÉTODO QUE DEVUELVE EL VALOR DE UN CUANTIL DADO COMO PARÁMETRO
    ## EL CUANTIL ES UN NÚMERO REAL ENTRE O Y 1

    def QF(self, p):
        "Función cuantil"
        return super().QF(p)

    ## MÉTODO QUE DEVUELVE LA PROBABILIDAD DE QUE UN X ESTÉ ENTRE A Y B 
 
    def Prob(self, ak, bk):
        "Probabilidad entre los valores a y b"
        return super().Prob(ak, bk)

    ## MÉTODO QUE DEVUELVE LA MEDIA DE LA DISTRIBUCIÓN 

    def mean(self):

        "Media"
        return super().mean()
    
    ## MÉTODO QUE DEVUELVE LA VARIANZA DE LA DISTRIBUCIÓN 

    def var(self):
        "Varianza"
        return super().var()

    ## MÉTODO QUE DEVUELVE LA DESVIACIÓN DE LA DISTRIBUCIÓN 
     
    def sd(self):
        "Desviación estándar"
        return super().sd()

    ## MÉTODO QUE DEVUELVE LA ASIMETRÍA DE LA DISTRIBUCIÓN 

    def skew(self):
        "Asimetría 'Skewness'"
        return super().skew()

    ## MÉTODO QUE DEVUELVE LA CURTOSIS DE LA DISTRIBUCIÓN 

    def EKurt(self):
        "Exceso de curtosis"
        return super().EKurt()

    ## MÉTODO QUE DEVUELVE LA MEDIANA DE LA DISTRIBUCIÓN 

    def Median(self):
        "Mediana"
        return super().Median()

    ## MÉTODO QUE DEVUELVE EL RANGO INTER CUARTÍLICO DE LA DISTRIBUCIÓN 

    def IQR(self):
        "Rango intercuartílico"
        return super().IQR()

    ## MÉTODO QUE DEVUELVE LA MODA DE LA DISTRIBUCIÓN 

    def mode(self):
        "Moda"
        return super().mode() #La moda es cualquier valor que toma x, dejaré fijo 0.5, pero mientras implemento el método para generar valores aleatorios entre 0 y 1

x1= rv_uniforme()
print(x1)
print("-"*80)

#Calcula la pdf de la variable aleatoria en x

s= x1.PDF(float(input("Por favor, ingrese el x al que le desea calcular la PDF: ")))
print("-"*80)


print("PDF(x): ", s)
print("-"*80)

#Calcula la cdf de la variable aleatoria en x
t= x1.CDF (float(input("Por favor, ingrese el x al que le desea calcular la CDF: ")))
print("CDF(x): ",t)
print("-"*80)

#Calcula un cuantil de la variable aleatoria en x
h= x1.QF(float(input("Por favor, ingrese el cuantil que desea obtener: ")))
print("QF(q): ",h)
print("-"*80)

#Calcula la probabilidad entre dos puntos ay b de la variable aleatoria 
y= float(input("Por favor, ingrese el menor valor del intervalo (A): "))
r= x1.Prob(y, (float(input("Por favor, ingrese el mayor valor del intervalo (B): "))))
print("PROBABILIDAD ENTRE A Y B:", r)
print("-"*80)


'''
MEDIDAS DESCRIPTIVAS DE TENDENCIA CENTRAL PARA LA VARIABLE X1- UNIFORME(0,1)
'''

print("MEDIDAS DESCRIPTIVAS DE TEN0DENCIA CENTRAL PARA LA VARIABLE X1- UNIFORME(0,1)")
print("-"*80)
#Calcula la media  de la variable aleatoria 
print("MEDIA: ", x1.mean)

#Calcula la varianza  de la variable aleatoria 
print("VARIANZA: ",x1.var())

#Calcula la desviación estándar  de la variable aleatoria 
print("DESVIACIÓN ESTÁNDAR: ", x1.sd())

#Calcula la asimetría  de la variable aleatoria 
print("SKEWNESS: ", x1.skew())

#Calcula el exceso de curtosis  de la variable aleatoria 
print("EXCESO DE CURTOSIS: ", x1.EKurt())

#Calcula la mediana  de la variable aleatoria 
print("MEDIANA: ", x1.Median()) 

#Calcula el rango intercuartílico  de la variable aleatoria 
print("IQR: ", x1.IQR())

#Calcula la moda  de la variable aleatoria 
print("MODE: ", x1.mode())

x2= rv_uniformecont(3, 6)
print(x2)
print("-"*80)


#Método que permite modificar los valores de soporte de la variable aleatoria 

x2.a= float(input("Por favor, ingrese el menor valor que toma la variable x (parámetro a): "))
x2.b = float(input("Por favor, ingrese el máximo valor que toma la variable x (parámetro b): "))
print(x2)
print("-"*80)


#Calcula la pdf de la variable aleatoria en x

s= x2.PDF(float(input("Por favor, ingrese el x al que le desea calcular la PDF: ")))
print("PDF(x): ", s)
print("-"*80)

#Calcula la cdf de la variable aleatoria en x
t= x2.CDF (float(input("Por favor, ingrese el x al que le desea calcular la CDF: ")))
print("CDF(x): ",t)
print("-"*80)

#Calcula el cuantil de la variable aleatoria en x
h= x2.QF(float(input("Por favor, ingrese el cuantil que desea obtener: ")))
print("QF(q): ",h)
print("-"*80)

#Calcula la probabilidad entre dos puntos ay b de la variable aleatoria 
y= float(input("Por favor, ingrese el menor valor del intervalo: "))
r= x2.Prob(y, (float(input("Por favor, ingrese el mayor valor del intervalo: "))))
print("PROBABILIDAD ENTRE A Y B:", r)
print("-"*80)

'''
MEDIDAS DESCRIPTIVAS DE TENDENCIA CENTRAL PARA LA VARIABLE X5- UNIFORME(A,B)
'''
print("-"*80)
print("MEDIDAS DESCRIPTIVAS DE TENDENCIA CENTRAL PARA LA VARIABLE X5- UNIFORME CONTINUA U(A,B)")
print("-"*80)

#Calcula la media de la variable aleatoria
print("MEDIA: ", x2.mean())

#Calcula la varianza de la variable aleatoria
print("VARIANZA: ",x2.var())

#Calcula la desviación estándar de la variable aleatoria
print("DESVIACIÓN ESTÁNDAR: ", x2.sd())

#Calcula la asimetría de la variable aleatoria
print("SKEWNESS: ", x2.skew())

#Calcula la curtosis de la variable aleatoria
print("EXCESO DE CURTOSIS: ", x2.EKurt())

#Calcula la mediana de la variable aleatoria
print("MEDIANA: ", x2.Median()) 

#Calcula el rango intercuartílico de la variable aleatoria
print("IQR: ", x2.IQR())

#Calcula la moda de la variable aleatoria
print("MODE: ", x2.mode())